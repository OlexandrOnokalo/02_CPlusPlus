1_Вступ до мови програмування C++

с++ - компільована мова програмування
Строго типізована мова

viasual studio

workloads - deckstop development with c++

ctrl + F5 - запуск програми
просто F5 - дебагер
ctrl + D - клон рядка

ctrl + alt + l  відкривається права панель з файлами

ctrl + K + F  виправляється формат коду

F10 debager

alt + стрілка - переносить рядок
ctrl + D - копіює рядок вниз
ctrl + shift + V - історія буфера 
ctrl + r + r - заміняє виділене скрізь 

-------------------------
#include<iostream>
using namespace std;

void main()
------------------------------


void main() - основна функція, точка входу в програму
void - озаначає що функція нічого не повертає

cout << "Hello world";  - типа принт 
cout << "You have to pay : " << price << " grn"; - вивід змінної price

Типи даних: - визначає першим ділом розмір комірочки і тип інформації що записуються
	1.Числові
		дроби
			float  - 4 bites
			double - 8 bites (16 цифр після коми
		цілі
			int - 4b 
			short 2b from -32768 to 32767
			long 4b 
			long long 8b - нереально велике число
			
			unsigned int - тільки в додатньому діапізоні
	2.Текст
			char - один символ 1байт (в одинарних ' ')
	3.Логіка
		bool - 1байт true false
	
	enum - набір цілочісельних констант
		
		enum Genre{none,History,Comedy} і тд - 

перетворення типів даних:
	Звужуюча форма (втрачаються частина даних) неявне
		int a = 23.5; - знаки після коми відкидаються 
	розширююче перетворення:
		double x = 3.21; (насправді х = 3,2100000000000000)
		
	явне перетворення:
		double k = 37.4; (37.400000000000000)
		float r = (int) k; (float 37.00000000)
	неявне:
		
	Уніфікована ініціалізація
		int num1 = 11.3; (num = 11.00000)
		int num2 = {11.3} - при компіляції буде помилка

Explicit - явно 
implicit - неявно


		
! 10,0 завжди сприймається як double
float c = 1.25; 1,25 сприймається як double і перетворюється на флоат

просто 10 приймається як int


		
правила назв зміних те саме що на пайтоні
при створенні зміної спочатку вказується тип
int age = 16;

Константа:
conts float PI = 3.14; - це значення вже змінити не можна

ввід з клавіатури:
int numer;
cout << "enter number: "
cis >> number;


========================================================================
02 logic operators

оператор - конструкція мови що призводить дії над даними

унарні -5 -1 -9 +6, інкримент ++, декремент --
Бінарні * - + / %

// - виводить ціле число а залишок пілся коми відкидає
% - виводить залишок після цілого ділленя. Якщо ==0, значить число ділиться без залишку. Коли меньше число ділимо на більше, тоді результат меньше число (10%12=10)

+= 
-=
%=
/=
*=

оператори порівння
	< > 

оператори рівності
	== дорівнює
	!= — не равно

Логічні оператори 
	1 (true)
	0 (false)
	&& - and
	|| - or
	!  - not
	if
	else if      (elif)
	else

Тернарний оператор	
	інкримент ++
		постфіксна форма: a++; (те саме що а += 1;)
		префіксна форма: ++а;  (те саме що а += 1;)

	декремент --
		постфіксна форма: a--; (те саме що а -= 1;)
		префіксна форма: --а;  (те саме що а -= 1;)

перетворення типів даних:
	Звужуюча форма (втрачаються частина даних)
		int a = 23.5; - знаки після коми відкидаються 
	розширююче перетворення
		int a = 3000000000; (не влазить значення

	
if (b==0)
{

}
else
{

}

Тернарний оператор
   ТВЕРДЖЕННЯ АБО ВИРАЗ ? ДІЯ1 : ДІЯ2;
		(b == 0) ? cout << "You can*t divide by zero!!!!" << endl : cout << "Result = " << a / b << endl;
		(b != 0) ? cout << "Result = " << a / b << endl : cout << "You can*t divide by zero!!!!" << endl;
		
		max = (a > b) ? a : b;
		min = (a < b) ? a : b;

========================================================================
03_Switch Enum

switch (grade)
	{
	case 'A':case 'a':
		cout << "Your grade is 5" << endl;
		break;
	case 'B':
		cout << "Your grade is 4" << endl;
		break;
	case 'C':
	case 'c':
		cout << "Your grade is 3" << endl;
		break;
	case 'D':
	case 'd':
		cout << "Your grade is 2" << endl;
		break;
	case 'F':
	case 'f':
		cout << "Your grade is 1" << endl;
		break;
	default:
		cout << "This grade is invalid\n";
		break;
	}
	
Якщо немає braak в case то виконується все кайси до того як наштовхнейться на брейк
char key то треба вказувати в один лапках 
	case '+':
int key то  
	case 1:

	case 'A':case 'a': - можна перераховувати кейси один за одиним і ставити їм уодну дію
	
enum - набір цілочісельних констант.

enum coins{penny = 1 , nickel = 5, dime =10 , quarter = 25 , half= 50 , dollar_coin = 100};

по замовчуванню, якщо не задати данні то задається 0,1,2 ітд
enum coins{penny, nickel, dime = 10, quarter, half= -1 , dollar_coin }; - йде спочатку 0,1,10,11, -1, 0
Тобто перерахування від вянказаного значення поки не вказати нове значення

========================================================================
Цикли
04_while 

Цикл з передумовою(while);

	int counter = 1;
	while (counter <= 7)
		{
		cout << "You have seen the " << counter <<
			" Wonder of the world!!!\n";
		counter++;
		}
	cout << "Now, you can begin your essay.\n";
	
Цикл з постумовою(do...while); //while True ..if break

	do
	{
		cout << "Choose operation : " << endl;
		cout << "[ 1 ] - If you want to Add two number " << endl;
		cout << "[ 2 ] - If you want to Deduct two number " << endl;
		...
		cin >> key;
		switch (key)
		{
		case 1:
			cout << "Enter a : "; cin >> a;
			cout << "Enter b : "; cin >> b;
			res = a + b;
			cout << "Answer : " << a << " + " << b << " = " << res << endl;
			break;
			
			.....
			
			cout << "Enter a : "; cin >> a;
			cout << "Enter b : "; cin >> b;
			if (b != 0)
			{
				res = a / b;
				cout << "Answer : " << a << " / " << b << " = " << res << endl;
			}
			else
			{
				cout << "\nError! You cannot divide by "
					"zero!\n";
			}
			break;
		case 0:
			cout << "Have a nice!!!" << endl;
			break;
		default:
			cout << "Wrong choice......" << endl;
			break;
		}
	} while (key!=0);


========================================================================
05_for_06_includeCycles

Цикл for, Вкладені цикли, Debuger

Цикл з параметрами(for).
 
	for (size_t i = 0; i < length; i++)
	
	for (int i = 0; i < 10; i++) - i створюються всередині циклу і знищується
	{
		cout << i << " ";
	}
break, continue працюють
	
Безкінечний цикл
int number;
	int sum = 0;
	for ( ;  ;  )// реалізація нескінченного циклу
	{
		cout << "Enter number : "; 
		cin >> number;
		if (number == 0)break;
		sum += number;
	}
	cout << "Suma all numbers = " << sum << endl;
	
Вкладені цикли

	int size = 10;

    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            if (i >= j && i + j >= size - 1)
                cout << "|===|";
            else
                cout << "     ";
        }
        cout << endl;
    }
	
========================================================================
Масиви, дебагер
07_Array

Типи помилок:
	- Помилка на етапі компілації (синтатична помилка)
	- Помилка на етапі виконання (прога запустилась але крашнулась)

Дебагер
F10 - старт дебагера спочатку коду, F10 переходимо на наступний рядок покроково
стаємо на потрібний рядок і F9, або зліва ставимо червону точку
F5 прога пробігає код до точкі зупинки, F10 далі
В циклі щоб не перебігати всі етирації циклу, правою кнопкою на точку зупинки і обираємо з умовами

Масиви (array) - набір однотипних даних об"єднаний загальним імя"м
	int arr[3]; - всі комірки будуть типу даних int
	arr[0] = 3;
	
	const int size = 5;
	int new_arr[size];
	int arr[size] = {1,30,5,4,7};
	int arr4[size] = {} - для того щоб все заповнилось нулями
Заповнення масиву за допомогою циклу
	cont int size = 5;
	int arr[size];
for (int i = 0; i < SIZE; i++)
    {
        cout << "Enter " << i + 1 << " element ";
        cin >> arr5[i];
    }
Вивід масиву
	for (int i = 0; i <SIZE; i++)
    {
        cout << arr5[i] << " ";
    }
    cout << endl;

========================================================================
08_Random_Matrix


Види пам"яті
Stack - статична память де зберігаються звичайні статичні змінні, і знищуються з будь яких фігурних дужках
Static - не ділянка яка зберігає статичні змінні які створюються на початку програми і знищуються коли програма закінччує свою роботу
HEAP - Heap Denamic memory

srand(time(0)); - вказує точку відправки відносно часу, вказується ОДИН раз на початку коду
а = rand(); - згенерує ціле число від 0 до 32767

ЧИСЛО В ДІАПАЗОНІ ВІД НУЛЯ ДО Х: rand() % X

ЧИСЛО В ДІАПАЗОНІ ВІД Х  ДО Y : rand() % (Y - X) + X
        //(16-11)
        a = rand() % (16-11) + 11;
		// -20 ... +20
		((rand() % 40) - 20)

		
void fillRandomUp(int arr[], int size, int left, int right)
{
	srand(time(0));
	for (int i = 0; i < size; i++)
	{
		arr[i] = (rand() % (right - left)+left);
	}
}		
		
		
		

Багатовимірні масиви 
Матриця - це сукупність одновимірних масивів

	srand(time(0));
	
	const int row = 5;
	const int col = 6;
	int array[row][col];
    
    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < col; j++)
        {
            array[i][j] = rand() % 90 + 10;//10...100
            cout << array[i][j] << " ";
        }
        cout << endl;
    }
    cout << endl;

========================================================================
09_Functions
Функції

Два способи оголошення функції
	- перед main
	- після main, тоді треба прописати до мейн прототип фукції 
		(прототип це перша строчка, напр int Hello ();
	
void Hello ()  (void значить що функція нічого не повертає)
{
	cout << "Hello"<<endl;
}


int sum(int a, int b)
{
	res = a + b;
	return res
}

result = sum(a,b);

Не можна створювати одну функцію всереди іншої. 
Не можна звернутися до функції до її оголошення

Звичайні змінні приходять як копії а масив - в оригіналі!!!!

Глобальна змінна - це змінна поза будь якими функціями, поза будь якими { }

Глобальні змінні інізіалізуються нулем.
int B; (B = 0)

int A = 99; - глобальна змінна
void main()
{
	int A - локальна змінна
	::A - звернення до глобальної зміної
}

Функція з дефолтними значенями
void StarDefault(int a = 20) - 20 це дефолтне значення, якщо аргумент не заданий користувачем

Пам'ять:
-Stack (глобальні і локальні змінні)
-Static - статистичні змінні
-Heap

Локальна змінна живе у одинних {}
Глобальна змінна - пишеться поза функціями
Статична локальна змінна - створюється функцією один раз і не стираєтсья з виходом з функції і знищуєтсья коли main закривається
	static int 


========================================================================
10_Overload_Function_and_Template

Інлайнові Фукції
inline void hello() - в кожне місце де є звернення до функції при підготовці до компіляції копіюється код функції, замість з того щоб пригати по строчкам. Разіонально використовувати для функції в один два рядки

Перезавантаження функцій
Створення кількох однакових функцій з однаковою назвою, але з різним початком int long float, і відповідно з прийомом різних видів данних аргумента, або різну кількість аргументів
	-перезавантаження функцій по виду данних
	- перезавантаження функцій по кількості елементів

int multy(int x)
{
	return x * x * x;
}
float multy(float x, float y)
{
	return x * x * y;
}
double multy(double x, double y, double z)
{
	return x * y * z;
}

Шаблони функцій
Дають змогу реалізовувати одну і ту ж функцію під різні типи данних (але НЕ для зміни кількості елементів)

template <typename T>
T max(T a, T b;
{
	return a > b ? a : b;
}

template <typename T1, typename T2 >
T2 Max(T1 a, T2 b)
{
	return a > b ? a : b;
}


========================================================================
11_Search_Arrange_array_Recursion
Пошук у масиві. Впорядкування масиву. Рекурсія.
Кирик Тетяна Анатоліївна

11__LinearSearchSort
Олена Сергіївна


Сортування вибором Selection Sort

void SelectSort(int arr[], int size)
{
	int temp, index;
	for (int i = 0; i < size; i++)
	{
		index = i;
		temp = arr[i];

		for (int j = i + 1; j < size; j++)
		{
			if (arr[j] < temp)
			{
				temp = arr[j];
				index = j;
			}
		}
		if (index != i)
		{
			arr[index] = arr[i];
			arr[i] = temp;

		}
	}
}


Бульбашка
bubble Sort
Постійне порівняння сусідніх елементів і заміна якщо вони не в тому порядку. Сама неоптимізована.
Постійним порівнянням 
Сложность алгоритма: В худшем и среднем случае: O(n²)

void BubbleSort(int arr[], int size)
{
	int temp;
	for (int i = 0; i < size; i++)
	{
		for (int j = size - 1; j > i; j--)
		{
			if (arr[j - 1] > arr[j])
			{
				temp = arr[j - 1];
				arr[j - 1] = arr[j];
				arr[j] = temp;
			}
		}
	}
}

Шейкерне сортування - оптимізована бульбашка
Як бабл тільки зувужуючі діапазон при знаходженні крайніх елементів
void ShakerSort(int arr[], int size)
{
	int j, index = size - 1;//9
	int left = 1, right = size - 1;
	int temp;
	do
	{
		for (j = right; j >= left; j--)
		{
			if (arr[j - 1] > arr[j])
			{
				temp = arr[j - 1];
				arr[j - 1] = arr[j];
				arr[j] = temp;
				index = j;//0
			}
		}
		left = index + 1;
		for (j = left; j <= right; j++)
		{
			if (arr[j - 1] > arr[j])
			{
				temp = arr[j - 1];
				arr[j - 1] = arr[j];
				arr[j] = temp;
				index = j;//9
			}
		}
		right = index - 1;
	} while (left < right);

}

Сортування вставкою

void InsertSort(int arr[], int size)
{
	int temp;
	int j;
	for (int i = 0; i < size; i++)
	{		
		temp = arr[i];
		for (j = i - 1; j >= 0 && arr[j] > temp; j--)
		{
			arr[j + 1] = arr[j];
		}
		arr[j + 1] = temp;
	}
}


Сортування Quick Sort Швидке сортування
Самий кращий метод сортування, скрізь використовується

Обираємо опорний елемент і все що більше вправо, все що меньше вліво, елемент стає на своє місце
Обирається новий опорний елемент і заново

void QuickSort(int arr[], int B, int E)
{
	int i = B, j = E;
	int temp, p;
	p = arr[(B + E) / 2];
	
	do
	{
		while (arr[i] < p)i++;
		while (arr[j] > p)j--;
		if (i <= j)
		{
			temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
			i++;
			j--;
		}
	} while (i <= j);
	if (B < j)QuickSort(arr, B, j);
	if (i < E)QuickSort(arr, i, E);
}




Рекурсія
Коли функція викликає сама себе
Переваги 
	можна оптимізованіше написати
	багато задач краще реалізовувати на рекурсії


Пошук у масиві

Лінійний пошук   - звичайний пошук через for

template <typename T>
int searchKey(T key, T arr[], int size)
{
	for (int i = 0; i < size; i++)
	{
		if (arr[i]==key)
		{
			return i;
		}
	}
	return -1;
}

Швидкий пошук для упорядкованого масиву (від меньшого до більшого)
template <typename T>
int searchKey(T key, T arr[], int size)
{
	for (int i = 0; i < size; i++)
	{
		if (arr[i] == key)
		{
			return i;
		}
		else if (arr[i]>key)
		{
			return -1;
		}
		cout << arr[i] << endl;
	}
	return -1;
}

Бінарний пошук ТІЛЬКИ по упорядкованому масиву ( на основі швидкому сортуванні)

int BinarySearch(int arr[], int size, int key)
{
	int B = 0, E = size - 1;
	while (true)
	{
		int p = (B + E) / 2;
		if (key > arr[p])
		{
			B = p + 1;
		}
		else if (key < arr[p])
		{
			E = p - 1;
		}
		else if (key == arr[p])
		{
			return p;
		}
		if (B > E) return -1;
	}
}


========================================================================
12_Pointers
Вказівник завжди має той самий тип даних що і те на що ми ставимо його

	int a = 5;
	int* pa = &a; - це буде вказівник на адресу змінної а, показує адресу комірки де лежить а.

а = 5  змінна а, в якій лежить значення 5
pa = &a = 0x0684864  - змінна ра, тип данних int* , яка зберігає в собі адресу 0x0684864 змінної а
*pa = 5 	коли ставимо * перед назвою змінної, куди ми зберегли адресу змінної а, нам покаже значення змінної

*(pa + 1) - значение ячейки следующей за а



	int a = 5;
	int* pa = &a;
	int b = 10;
	int* pb = &b;
	cout << a + b << endl; 		- покаже суму змінних а і b
	cout << *pa + *pb << endl;  - також покаже суму змінних а і b

	pa = &b; - тепер ми в змінну ра поклали адресу змінної b

	const int size = 5;
	int arr[size];
назва масиву і є адресою першої комірки!!!!!!
	int* p_arr = arr;  -   назва масиву і є адресою першої комірки!!!!!!

	int* newptr = arr; 	— создается указатель newptr, который указывает на первый элемент массива arr.
	*newptr = 0; 		— записывает 0 в первый элемент массива.
	newptr += 3; 		— сдвигает указатель на три элемента вперед (т. е. newptr теперь указывает на arr[3]).
	*newptr = 0; 		— записывает 0 в arr[3]

Вивід масива на екран через вказівники
	p_arr = arr;
	for (int i = 0; i < size; i++)
	{
		cout << *p_arr << " ";
		p_arr++;
	}

Заміна парних і не парних елементів
	const int size = 6;
	int arr[size] = { 10,20,30,40,50,60 };
	int* parr = arr;

	for (int i = 0; i < size - 1; i += 2) 
	{
		int temp = *(parr + i);
		*(parr + i) = *(parr + i + 1);
		*(parr + i + 1) = temp;
	}
	
int a = 10;
int* ptr = nullptr; - створення порожнього вказівника

========================================================================
13_PointerInFunctionLinks

Вказівники у функціях

	a=0;
	ChangeVariable(&a) - передаємо адресу змінної а в фукцію

ChangeVariable(int* pa) - функціЯ отримує фактичну адресу змінної
{
(*a)++; - змінює безпосередньо значення змінної по вказівнику
}


int* FindMax(int* arr, int size) - передається просто змінна arr, яка і є вказівником на нульовий елемент масиву
{
    int* max = arr;
    for (int i = 0; i < size; i++)
    {
        if (*(arr + i) > *max)  - * вказує що достати значення, arr+i вказує з якої комірки)
        {
            max = arr + i;
        }
    }
    return max;
}

========================================================================
14_Links
Лінки  Посилання

Посилання (ссилка) link
	int c = 7;
	int& lc = c; - створили адресу (типу int&) на змінну с
Тобто змінна lc має доступ до значення с.

	void change(int& a)   - Вносимо посилання в функцію, і вноситься зміни в оригінал за посиланням 
	{
		a++;
	}

Для масивів
 передаємо аrr, що є вказівником на 
 індекс arr
	
	int& FindMax(int* arr, int size) 
		int max = arr[0];
		int index_max = 0;
		for (int i = 0; i < size; i++)
		{
			if (*(arr + i) > max)
			{
				max = *(arr + i);
				index_max = i;
			}
		}
		//max= 81; index_max = 5
		return arr[index_max];//81
	}
Вертається посилання на відповідну комірку в arr 

========================================================================
15_CStyleLines
Рядки C-style - це масив типу даних char 

char mystring[]= "string"; 
В кінці ставиться нуль-термінатор, тому 7 символям в масиві
sizeof(mystring) - показує розмір масиву
cout <<  - виводить все з масиву до нуль-термінатора (\0)
	
	char myname[255];
	cout << "Enter name: << endl;
	cin.getline(myname, 255) -  Записує всі символи у в кінець ставить нуль
термінатор. Якщо символів більше, лишнє обріже
	
	char text[] = "Print this!";
	char copy[50];
	
	strcpy_s(copy, text); - копіює з одного массиву в інший
	
	char name[255] = "Olena"
	sizeof(name) = 255 - показує розмір масиву (контейнеру), скільки створено
елементів 
	strlen(name)  = 5 - показує кількість реально збережених символів
	
	
	
========================================================================
16_FormatFunction
SetPos, SetColor

#include <iomanip>
#include <Windows.h>

setw(n) - кількість комірок, зарезервованих в консолі. Впливає на все, що виводиться після нього
	cout << setw(3)<< "A" << endl; - виводиться місце під 3 символи і розташовує А справа
	cout << left << setw(3)<< "A" << endl; - тепер зліва

void SetColor(int color)
{
    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);
}

	
void SetPos(int x, int y)
{
    COORD c;
    c.X = x;
    c.Y = y;
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), c);
}


system("cls"); - затирає консоль


========================================================================
16_LinesFunction

Рядки. Стандартні рядкові функції.
Кирик Тетяна Анатоліївна

#include <cstring>

const int size = 200;
char str[size] = "C style string - Standart function strcpy()";
cout << str + 20 << endl; - показує рядок з 21 символа
char copyStr[size]

strcpy_s(copyStr, str); - копіює з str  у copyStr
strcat_s(copyStr, "new text") - приєднує текст до кінця рядка

strcmp(one,two);  - результат 0, значить однак4ові
більше нуля - перший рядок більший
меньше нуля - перший рядок меньший

strncmp(one,two, 4) - рівняються тільки 4 символа
_stricmp(one,two) - ігнорує регістр

strlen() - повертає кількість символів



Функції пошуку

пошук символу:
char symbol = 't';
char* p = 

strchr(str,symbol); - вертає вказівник на ячейку з першим входженням (шукає спочтку), або nullptr якщо не знайшла 

strrchr(str,symbol); - шукає справа (останнє входження)

пошук слів
strstr(str,word); - вертає вказівник на першу букву цього слова

========================================================================

17_Dynamic_array_Dynamic_memory

Динамічна пам'ять. Динамічні змінні та масиви.

Види памяті
1) Global and static data (глобальні змінні)
2) stack (LIFO) - локальні змінні
3) Dinamic memory (heap, free memory) 

HEAP:

створення змінної в HEAP
new int {123}

Для доступу треба створити вказівник
int* p = new int {123} - значення 123 зберігаєтсья на HEAP, а сам вказівник р в стеку 
delete p; - видалення динамічної змінної в HEAP
Тепер вказівник p показує в собі сміття
p = nullptr; - затираємо сам вказівник


Динамічні массиви

int size = 20;  - розмір може бути не статичним
int* arr = new int[size] {}  - arr (вказівник на стеку) а данні в HEAP


void printArray(const int* arr, int size)
{
	cout << "Array: ";
	for (int i = 0; i < size; i++)
	{
		cout << "\t" << arr[i];
	}
}
void fillArrayWithRand(int* arr, int size)
{
	static bool firstTime = true;
	if (firstTime) {
		firstTime = false;
		srand(unsigned(time(0)));
	}
	for (int i = 0; i < size; i++)
	{
		arr[i] = rand() % 100;
	}
}

В функцію вводим int * & arr, виходить посилання на вказівник, в кінці arr = temp; - щоб вказати по посиланню вказівник уже на новий массив


========================================================================
18_Pointer_to_pointer_Dynamic_Matrix
Вказівник на вказівник. Динамічні двовимірні масиви

	int * p = new int{120}; - вказує на ділянку в хіпі
	int * * p2 = &p. - він вказує на р, тобто він містить адресу самої змінної р.

	cout<< **p2<< endl; - показує зміст 120

	*(arr+i) = arr[i]

	int * arr = new int [3] {100,200,300}
	arr[0] = *(arr+0)



Динамічні двовимірні масиви

Полу динамічний:
	const int ROWS = 3;
	int * matrix[ROWS];
	int cols = 4;


	matrix[i] = new int [cols] {};
	*(*(matrix+1)+2) =  matrix[1][2] - 
	matrix[0][0] = 120; - задаємо значення
	delete [] matrix [i]


Повно динамічний масив

int rows; (просто НЕ константа змінна, можно з клавіатури)
int cols; (просто НЕ константа змінна, можно з клавіатури)

int ** matrix = new int* [rows]; (вказівник на динамічну матрицю, але поки створенний тільки масив ВКАЗІВНИКІВ на майбетні рядки



int** createMatrix(int rows, int cols) {
	int** matrix = new int* [rows];
	for (int i = 0; i < rows; i++)
	{
		int* row = new int[cols] {};
		matrix[i] = row;

	}

	return matrix;
}


void printMatrix(int** m, int r, int c)
{
	if (m == nullptr)
	{
		cout << "Empty matrix!\n";
		return;
	}
	for (int i = 0; i < r; i++)
	{
		for (int j = 0; j < c; j++)
		{
			cout << m[i][j] << "\t";
		}
		cout << endl;
	}
}

void removeMatrix(int**& m, int r)
{
	for (int i = 0; i < r; i++)
	{
		delete[] m[i]; // вилучаємо кожен рядок у циклі
	}
	delete[] m;  // вилучаємо масив вказівників
	
	m = nullptr;
}


void addRow(int**& m, int& r, int c, int value)
{
	++r; // збільшили кількість рядків + 1
	int** tmp = new int* [r]; // створили маси вказівників на рядки більшого розміру +1

	for (int i = 0; i < r - 1 ; i++)
	{
		tmp[i] = m[i]; // перечипили старі рядки у новий масив вказівників 
	}

	tmp[r - 1] = new int[c]; // створили новий рядок як останній у новій матриці
	for (int j = 0; j < c; j++)
	{
		tmp[r - 1][j] = value; //заповнили новий рядок однаковими значеннями value
	}

	delete[] m;
	m = tmp;
}




========================================================================
19_Pointer_to_function

Вказівники на функції

назва функції це і є адреса, на яку можна призначити вказівник

int fun(int v){
	return v*v;
}
	

	double (*ptr)(double); - створення вказівника, який можна назначити на функцію, яка має один параметр типу дабл, і повертає теж дабл
	
	ptr = fun; - посилаєтсья на фукнцію fun
тепер можна писати ptr(value) - і це буде тесаме що fun(value)


double (*arrFun[SIZE]) (double) = {sqr, cube, power}; = це масив вказівників на функції

arrFun[0](value) - викликали фукнцію sqr з масиву вище

Якщо звверху написати 
	using PtrIntType = int*; - тепер замість int* можна використовувати PtrIntType

	void changeArray(int* arr, int size, int func(int)) 
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = func(arr[i]);
    }
}

void arraysAction(int arr1[], int arr2[], int arr3[], int size, int func(int, int)) {
    for (int i = 0; i < size; i++)
    {
        arr3[i] = func(arr1[i], arr2[i]);
    }
    print(arr3, size);
}


========================================================================
20_preprocessor

Препроцесор - програма, яка працює ДО початку компіляції сpp-програми, виконує ТЕКСТОВІ заміни у коді.

#define SIZE 5 // визначили препроцесорну константу, препроцесор далі по коду позамінює SIZE на 5

#define MAX(a,b) ((a)> (b)? (a): (b)) // визначили макрос з іменем MAX, макрос має два параметри, у точку виклику макроса препроцесор підставить тіло макросу на фактичних параметрах

#define DOUBLE



void main(){

#ifdef INTEGER // якщо визначено препроцесорне імя INTEGER, 
	int matrix[ROWS][COLS]{ 1,2,3,4 }; // то створюється матриця з цілих чисел
#elif defined(DOUBLE) // інакше, якщо визначено препроцесорне імя DOUBLE,
	double matrix[ROWS][COLS]{ 1.1,2.2,3.3, 4.4 }; // то створюється матриця з дробових  чисел
#else          //інакше
	char matrix[ROWS][COLS]{ 'a','b','c','d' };// то створюється матриця з символів
#endif

}

========================================================================
21_Structure
Структури

const int size = 20;
struct Dog    - структура з наступними змінними, Dog як шаблон
{
	char nick[size] = "Noname"; - значення по дефолту
	char size[size] = "Unknown";
	int age = 0;
	char color[size] = "Nocolor;
	
};



void printDog(const Dog& dog)     ставимо const щоб не можна було змінити, а посилання бо так швидше чим просто копія (витрачається лишній час)
{
	cout << "\nDog's nick : " << dog.nick << endl;
	cout << "Dog's size: " << dog.size << endl;
	cout << "Dog's age : " << dog.age << endl;
	cout << "Dog's color : " << dog.color << endl;
	cout << endl;
}

void inputDog{Dog& dog) - функція має змінювати ставимо за посилання & 
{
	cout << "Enter nick : ";
	cin >> dog.nick;
	cout << "Enter size : ";
	cin >> dog.size;
	cout << "Enter age : ";
	cin >> dog.age;
	cout << "Enter color : ";
	cin >> dog.color;
}


Dog olderDog(const & dog1, const Dog & dog2)
{
	 if (dog1.age >= dog2.age)
		 return dog1;
	 return dog2;
}



dog.nick = це беспосередньо змінна
dog->age=5; - це посилання

	
main(){
	Dog dog{"Jack", "medium", .....};  - створили екземпляр dog типу Dog
	dog.age = 2; - Вказуємо значення змінної age в dog
	
	cin >> dog.nick; - захватуємо з клавіатури
	
	Dog cloneJack = dog; - всі елементи об"єкта dog скопіюється в cloneJack
	
	
	
	Dog * dog3 = new Dog("bobik", "Big", 4, "black");
	
	dog->age=5; - операція доступу до елемента структури через вказівник
	printDog(*dog3);
	
	// . операція доступу до елемента структури через обєкт 
	// -> операція доступу до елемента структури через вказівник 	
	
	}
	
	
Массив структура
array of structs

struct Product
{
	char name[MAX_LEN];
	double price;
};



void printProduct(const Product& product)
{
	cout << "Product: '" << product.name << "', price: " << product.price << endl;
}

void printShop(const Product  shop[], int actualSize)
{
	for (int i = 0; i < actualSize; i++)
	{
		cout << "#" << i + 1 << "\t";
		printProduct(shop[i]);
	}
}

void printProducts(const Product shop[], int actualSize, const char* name)
{
	cout << "Products with name like '" << name << "'\n";
	for (int i = 0; i < actualSize; i++)
	{
		//if (_stricmp(name, shop[i].name) == 0) // чи співпадають рядки?
		if (strstr(shop[i].name, name)!=nullptr) // чи name є частинрою назви товару shop[i].name
		{
			printProduct(shop[i]);
		}
	}
}

main(){
	const int MAX_SIZE = 10;

	int actualSize = 3;
	Product shop[MAX_SIZE]
	{
		{"Bread bread", 2.20},
		{"Bread white", 1.80},
		{"Yogurt", 3.10},
		{"Apple juice", 2.77},
	};
	printShop(shop, actualSize);
	cout << endl;

	printProducts(shop, actualSize, "Bread");
	cout << endl;
	Product milk{ "Milk", 2.45 };	
	addProduct(milk, shop, actualSize, MAX_SIZE);
	printShop(shop, actualSize);
	
}

}


========================================================================
22_Nested structs_Dynamic_array_struts

Вкладені структури. Масив структур. Робота з файлами

﻿#include <iostream>
#include <cstring>
#include <string>

using namespace std;

	
struct Employee {
	string fullName;
	string position;
	int age;

	struct Contacts {
		string email;
		string phone;
	};

	Contacts contacts;
};


employee.contacts.email - доступ до поля вкладенної структури

Employee::Contacts contacts = {"coname@gmail.com","XXXXXXXX"]; - доступ якщо структура вкладена


void printContacts(const Employee::Contacts contacts)
{
	cout << "Email: " << contacts.email << endl;
	cout << "Phone: " << contacts.phone << endl;
}

void printEmployee(const Employee& employee)
{
	cout << "Full Name: " << employee.fullName << endl;
	cout << "Position: " << employee.position << endl;
	cout << "Age: " << employee.age << endl;
	printContacts(employee.contacts);
}




void addEmployee(const Employee& empl, Employee*& company, int & actualSize, int& capacity)
{
	if (actualSize >= capacity)
	{
		cout << "Not enough space!\n";
		return;
	}
	++actualSize;
	Employee* tmp = new Employee[actualSize];
	for (int i = 0; i < actualSize - 1; i++)
	{
		tmp[i] = company[i];
	}
	tmp[actualSize - 1] = empl;

	delete[] company;
	company = tmp;
}




int main()
{
	int capacity = 10;

	int actualSize = 0;
	Employee* company = new Employee[capacity];// nullptr

	Employee emp{ "Daria D.", "QA", 24, {"daria@gmail.com", "0908678565656"} };
	addEmployee(emp, company, actualSize, capacity);
	
	Employee emp2{ "Sergii S.", "BA", 34, {"sergii@gmail.com", "09086788888"} };
	addEmployee(emp2, company, actualSize, capacity);

	printCompany(company, actualSize);

	delete[] company;
}





Запис у файл

#include <fstream> - file stream

int main()
{
	string fname = "my.txt"; (файл створиться або перезапишеться, якщо вже є)
	ofstream f(fname); // створили обєкт файлового потоку f і повязали цей потік з фізичним файлом
	if (!fout.is_open())
    {
        cout << "Error opening file\n";
        return 0;
    }
	f << "Hello"; - записує в файл
	f.close(); - закриває файл
	
	ifstream fin(fname);
    char readText[256];
    int readValue;

    //fin >> readText; // прочитає перше слово
    fin.getline(readText, 100);
    fin >> readValue;

    cout << "Read text from file : " << readText << endl;
    cout << "Read value from file : " << readValue << endl;
	
}

========================================================================
Intro to OOP
23_IntroToOOP

звичайний масив-однотипних даних
struct - масив різнотипних данних. - object (складний тип даних)


Структурне (процедурне) програмування - працює тільки з глобальними функціями і треба було передавати обєкт

Об"єктно орієнтоване програмування
Функції описуються всередині class

Три кити ООР
	-інкапсуляція Encapsulation - властивість пов"язати дані та методи роботи всереди класу (в клас ми вкладаємо змінні, що характеризують обєкт і методи работи з цими змінними)
		- змінні члени класу треба приховати to private
		- далі в паблік пишемо методи роботи з змінними
	
	-наслідування inheritance - роблять базовий клас і на основі його роблять дочірниій клас
	
	-поліморфізм - економія понять. Коли у багатьох класах метод називається однаково а реалізацію має свою.
		
	Метод (функція) завантажити.
	В автомобіль - відкрити і сісти
	в мотоцикл - по своєму


struct - це public
class - по замовчуванню privat


class Student      - клас, назва унікальна
{
private:	
	string name;		- це змінні члени класу  (data members)
	string surname;
	int marks[3];


public: - щиб до методів був доступ ззовні	
	double getAvr()    - це фукції члени класу, методи (класу) (метод це всерелині класу, фукнкцією називають глобальні)
	
	void setName(string name) - це сеттер (Set). Метод щоб встановити значення
	{
		this->name = name;
	}
	
	string getName()      -це геттер, який виводить значення
	{
		return name;
	}
	
};


int main()
{
	Student st;
	st.setName("Tom"); - використовуємо сеттер щоб внести значення
	cout << st.getName(); - геттер вертає імя

setter getter -це по замовчуванні інлайнові функції



getline(cin, name1);
========================================================================
24_Constructor_Destructor

Constructor, Destructor


Конструктор - це функція що завжди належить до свого  завжди має назву классу і має ()
Не повертає значення, не пишеться void return.
По замовченюванні конструктор вже є.
А самостійно можно очистити сміття і вказування дефолтних значень під час конструкції

Конструкторів може бути безліч

Student st2("Tom","tomson" ... )  - це параметризований конструктор, при створенні обєкта засускається один з конструкторів в залежності від кількості аргументів і типів данних. А нема аргументів, то дефолтний. 
	Але якщо є тільки створений конструктор з параметрами, то дефолтний не буде спрацьовувати
ctor + TAB
	
Деструктор - якщо нема динамічних данних, то деструктор не потрібен, вистачає дефолтного. А якщо є динамічні дані то обовязково треба. Деструктором вказується черговість видалення данних


class
  \\ default constructor
  \\ paramet - паратомезований
  \\ конструктор копіювання
  
  \\деструктор
  


struct PIB {
	string name;
	string surname;
	string lastname;
};
struct Birthday {
	int day;
	int month;
	int year;
};

class Student
{
private:
	PIB fullname;
	Birthday birthday;
	string phone;
	string city;
	string country;
	string university_name;
	string university_city;
	string university_country;
	string group; !!!!!!!
	int* marks;  - цей вказівник поки пустий
	int markCount;  - поки що нуль
	float average;
public:
	Student() - конструктор в заміну дефолтному без аргументів, ctor + Tab
	{
		cout << "Default constructor " << endl;
		fullname.name = "no name";
		fullname.surname = "no surname";
		fullname.lastname = "no lastname";
		birthday.day = 0;
		birthday.month = 0;
		birthday.year = 0;
		phone = "no phone";
		city = "no city";
		country = "no country";
		university_name = "no university_name";
		university_city = "no university_city";
		university_country = "no university_country";
		group = "no group";
		marks = nullptr;
		markCount = 0;
		average = 0;
	}
	Student(string name, string surname, string lastname) - це параметризований конструктор(опис вище)
	{
		cout << "Parametrized constructor " << endl;
		fullname.name = name;
		fullname.surname = surname;
		fullname.lastname = lastname;
		birthday.day = 0;
		birthday.month = 0;
		birthday.year = 0;
		phone = "no phone";
		city = "no city";
		country = "no country";
		university_name = "no university_name";
		university_city = "no university_city";
		university_country = "no university_country";
		group = "no group";
		marks = nullptr;
		markCount = 0;
		average = 0;

	}
	
	void SetName(string name) - сеттери
	{
		fullname.name = name;
	}
	void SetSurName(string surname)
	{
		fullname.surname = surname;
	}
	void SetLastName(string lastname)
	{
		fullname.lastname = lastname;
	}
	
	void Print()
	{
		cout << fullname.name << endl;
		cout<< fullname.surname << endl;
		cout<< fullname.lastname << endl;
		cout<< birthday.day << endl;
		cout<< birthday.month << endl;
		cout<< birthday.year << endl;
		cout<< phone << endl;
		cout<< city << endl;
		cout<< country << endl;
		cout<< university_name << endl;
		cout<< university_city << endl;
		cout<< university_country << endl;
		cout<< group << endl;
		cout<< "marks : " ;
		for (int i = 0; i < markCount; i++)
		{
			cout << marks[i] << " ";
		}
		cout << endl;
		cout<< markCount << endl;
		cout<< average << endl;
	}
	void AddMark(int mark)
	{
		//marks = nullptr;
		//markCount = 0
		markCount++;         - змінюємо динамічний масив
		int* temp = new int[markCount];
		for (int i = 0; i < markCount - 1; i++)
		{
			temp[i] = marks[i];
		}
		temp[markCount - 1] = mark;
		if (marks != nullptr)
			delete[] marks;     - чистимо память на яку вказує маркс
		marks = temp; - назначаємо на вказівник маркс новий массив на який вказував темп
		setAverageMark();
	}
	
	
	~Student() - деструктор. Пищем ~ + TAB
	{
		cout << "Destructor " << fullname.name << endl;
		//Delete();
		if (marks != nullptr)
			delete[] marks;
	}
	
		
}

int main{)
{
	Student student;  - спрацьовує дефолтний конструктор, або створенний але без аргументів
	student.Print();
	
	Student st2("Tom", "Tomson", "Lastname"); - це параметризований конструктор, при створенні обєкта засускається один з конструкторів в залежності від кількості аргументів і типів данних. А нема аргументів, то дефолтний. 
	Але якщо є тільки створений конструктор з параметрами, то дефолтний не буде спрацьовувати
	
}


this - вказівник на конкретний клас, в якому він знаходиться

========================================================================
25_CopyConstructor

Ініціалізація з копіюванням.
int b = 3; - створює змінну, і оператор "=" копіює літерал 12

Уніфікована ініціалізація
int a = {5.12} - замість обрізання до 5, при компіляції буде помилка 

Пряма Ініціалізація:
int value(15); 



Конструктор копіювання:
Всі змінні копіюється значення
Але якщо це вказівник, то він буде вказівати на той же обєкт

Student.student;
Student.student1(student) - конструктор копіювання копіює в student1 клас student. Але вказівник буде вказувати на дані оригиналу, бо скопіюється адреса вказівника

ctor + TAB
Student(const Student& other)
	{
		this->name = other.name;//Nick --> Nick
		this->age = other.age;  //15 --> 15
		this->markCount = other.markCount;//4 --> 4

			А отак копіюються динамічний массив:
		this->marks = new int[other.markCount];
		for (int i = 0; i < other.markCount; i++)
		{
			this->marks[i] = other.marks[i];
		}
		
		this->average = other.average;// 9.25 ---> 9.25
	}
	
	або так:
	
Array(const Array& other) {
        this->size = other.size;
        if (this->size > 0) {
            this->arr = new long[this->size];
            for (int i = 0; i < this->size; ++i) {
                this->arr[i] = other.arr[i];
            }
        }
        else {
            this->arr = nullptr;
        }
    }
	

========================================================================
26_InlineMethodsDelegationStaticFunction

Inline functions, static methods

Інлайнові Фукції
inline void hello() - в кожне місце де є звернення до функції при підготовці до компіляції копіюється код функції, замість з того щоб пригати по строчкам. Разіонально використовувати для функції в один два рядки

Всі методи що в класі по замовчуванню інлайнові
Але якщо метод більше пари рядків, це інлайн компілятором буде проігнорувати.

Делегування кострукторів

Human() 
{
	name="no name" 
	age = 0;
	weight = 0;
}
	Human(string name):Human() - цей конструктор делегується до Human()
Human()  - дефолтний конструктор
	{
		name = "no name";
		age = 0;
		weight = 0;
		count_human++;
	}
	Human(string name):Human()  - цей конструктор делегується до Human()
	{
		this->name = name;
	/*	age = 0;
		weight = 0;*/
	}
	Human(string name, int age):Human(name)
	{
		//this->name = name;
		this->age = age;
		//weight = 0;
	}
	Human(string name, int age, int weight):Human(name,age)
	{
		//this->name = name;
		//this->age = age;
		this->weight = weight;


має бути один конструктор який ні до яких не делегується

Статична змінна 
	public:
		static int count_human; - не можна ініцілізувати в межах классу
	

статичні змінні обовязково поза классом
int Human::count_human = 0;
Ця змінна загальна для всіх

Human()  - дефолтний конструктор (ctor + TAB)
{
	name="no name" 
	age = 0;
	weight = 0;
	count_human++;   - якщо є дилегування то треба тілько в дефолтному конструктору. Якщо делегування немає, то в кожном конструкторі
}
	
	
Тоді треба прописувати декструктор
~Human(){
	count_human--;
	}

static int getCountHuman(){    - статична фукція
	return count_human;
}

Статична функція для роботи з статичнимим змінними
Статична змінна створюється один раз.
В статичних методах this немає.

========================================================================
27_ConstExplix
OOP. Константний метод. Kлючовe словo explicit

const int size = 3; - констант, можна використовувати з будь яким типом данних

Змінна - це іменована ділянка памяті в яку ми можемо зберігати певне значення і має певний вид памяті

Обєкт - Об'єкт - це коли ми створюємо свій тип даних і може вміщувати потрібні змінні.


По замовчуванні компілятор ходить 2 рази. Спочатку робить змінну, а потім її інціалізує. Так з константою не працює

class Date
{
	int day;
	int month;
	int year;
	const int baseYear;
public:
	Date():day(0),month(0), year(0), baseYear(2025){} - список ініціалізації, так правильно ініцаалізувати таким чином в будь якому випадку, і з конст також
	
	void Print() const - вказуємо що цей метод гарантовано нічого змінювати не буде. Працювати буде і с константними і звичайними обєктами 
	Правильно писати гетери і прінти, які виводять інформацію і нічого не змінювати, треба писати const, щоб працювало і з контс і звичайними
};

int main()
{
	const Date Day{24,08,2025};
	Day.Print()      -  тоді обєкт довіряє методу Print і працює
	

Правильно писати гетери і прінти, які виводять інформацію і нічого не змінювати, треба писати const

	
27_01_Explicit

float doSomething()
{
    return 10.0; 
}
int main()
{
    int a = 3.33;//double --> int 

    double b(10);//int --> double
    doSomething(5);//int --> long

    float c = 1.25; 1,25 сприймається як double і перетворюється на флоат

Неявне перетворення в обєктах:

class Array
{	
	int size;
	int* arr;
public:
	int getSize()const
    {
        return size;
    }
	int getValue(int index)const
    {
        return arr[index];
    }
	void setValue(int value, int index)const
    {
        arr[index] = value;
    }


void Display(const Array &arr)
{
    for (int i = 0; i < arr.getSize(); i++)
    {
        arr.dispay(i);
    }
    cout << endl;
}

main()
{
			
	Display(10); - неявне перетворення від int до обєкта Array

конструктор:
	explicit Array(int size) - треба вказувати в бодь якому конструкторі з одним рагументом
    {
        this->size = size;
        this->arr = new int[size];
    } 
	

	//explicit - явно
    int r = (int)2.33;
    //imlpicit - неявно   
    int a = 3.33;//double --> int 

Explicit - явно 
implicit - неявно

========================================================================
28_OverloadOperators


#region + tab !!!!!!!!!!!!!!!!!!!!!

Перезавантажені оператори

-поліморфізм - економія понять. Коли у багатьох класах метод називається однаково а реаліхацію має свою.

Для того щоб навчити компілятор +, -, * і тд роботі з вашими классами - тоді треба створювати перезаваантажені оператори

Оператори:
унарні -5 -1 -9 +6, інкримент ++, декремент --
Бінарні * - + / %


!!!!	Нащо перезавантажувати оператори - для того щоб навчити компілятор оперувати нашими типами данних.



class Point
{
	int x;
	int y;
public:


		Унарні оператори працюють з одним обєктом
		
#pragma region Uno operators
    // + - ++ --
    Point operator -()const
    {
       Point res(this->x * -1, this->y * -1);
       return res;
    }	
#pragma endregion


		Бінарні оператори - працюють з двома аргументами
		
	Point operator +(const Point& other)const 
    {
        Point res(this->x + other.x, this->y + other.y);
        return res;
    }
    Point operator -(const Point& other)const
    {
        Point res(this->x - other.x, this->y - other.y);
        return res;
    }
    Point operator *(const Point& other)const
    {
        Point res(this->x * other.x, this->y * other.y);
        return res;
    }
    Point operator /(const Point& other)const
    {
        Point res(this->x / other.x, this->y / other.y);
        return res;
    }	
	
	
	Point operator += (const Point& other) 
    {
        this->x += other.x;
        this->y += other.y;
        return *this;
    }
	
	Point operator =(const Point& other)
    {
        this->x = other.x;
        this->y = other.y;
        return *this;
    }
	
		Логічні оператори
		
	bool operator >(const Point& other)
	{
		return  (this->x + this->y) > (other.x + other.y);
    }
	bool operator ==(const Point& other)
    {
        return  (this->x == other.x) && (this->y == other.y);
    }
	bool operator !=(const Point& other)
    {
        return  (this->x != other.x) || (this->y != other.y);
    }
		
		
main()
{
	Point p1(5,7);
	Point p1(3,4);
	Point res;
	
	res = p1 + p2; - ми навчили компілятор додавати наш тип даних
	p1 += p2;      - міняти оригінал як p1=p1+p2;
	res = -p1; - або створює нове, або змінює оригінал, як зробиш метод, але краще створює і передає нове, бо:
	p1 = p2 = p3; - справа на ліво, бере р3 ложимо в р2, і р2 ложимо в р1
	
	



Префіксна форма:
Point operator++( Point & other)
{
    other.x++;
    other.y++;
    return other;
}

При перезавантаженні виходить Префіксна форма 
++p1;


bool operator <(const Point& left, const Point& right)
{
    return  (left.x + left.y) < (right.x + right.y);
}


Якщо це власний клас, то змісту робити перезавантаження глобальною функцією немає
Але якщо використовуємо клас із бібліотеки то так




========================================================================
29_OverloadOperator_friendFunction	



friend function
В класс додаєм прототип
а саму функцію глобально
і тоді ця функція довірена, дружня
Але цей принцип порушує інкапсуляцію




	В структурі може бути show i конструктори
struct Vagon {
    int number;
    int places;
    int passengers;
    Vagon() :number(0), places(0), passengers(0) {}
    Vagon(int n, int p, int pass) :number(n), places(p), passengers(pass) {}
    void Show()const
    {
        cout << "Vagon number: " << number << endl;
        cout << "Vagon places: " << places << endl;
        cout << "Vagon passengers: " << passengers << endl;
    }    
};


перезавантаженя [] i ()

Vagon operator[](int index)      - можна тільки в середині класу
    {
        if (index < 0 || index > vagonCount) { return Vagon(); }
        return vagons[index];
    }    


void operator()(int count)
    {
        for (int i = 0; i < vagonCount; i++)
        {
            vagons[i].passengers += count;
        }
    }

ostream& operator << (ostream& out, const Point& other)
{
    out << "x = " << other.x << " . " << "y = " << other.y;
    return out;
}
istream& operator >> (istream& in, Point& other)
{
    
    in >> other.x;
    in >> other.y;
    return in;
}

		
Перетворення наших класів до стандартних одиниць і навпаки

	 RectangleNew rectangle(5, 7)  стандартний до абстрактного
	
	перезавнаження типу даних в классі
	
	explicit operator int()   - абстрактний до стандартнонго
    {
        return height * width;
    }
	
	
========================================================================	
30_LibraryOperator=

Файли:
Проект book

проект - адд - клас, там називаємо хедер по назві класу
Header files/Book.h - header
утворюється  - source/Book.cpp
		тут #include <iostream>
			using namespace std; і так далі
			
в хедері описуем класи
на початку пишемо
	#pragma once  - для того щоб підключило тільки один раз
якщо метод в класі довший одного рядка переносим його в Book.cpp  (лампочка і мув дефінітіон)
!!!! стираємо inline !!!!


Book::Book() - це в book.cpp метод але вказується до якого класу цей метод відноситься 
	{
	}
	
в хедері пишем прототип, нажимаємо на викрутку  і create definition ... і нас перекидає в book.cpp де пишемо уже метод


потім маєм файл cpp з назвою проекта де мейн 	


для нового класу знову адд клас і додаємо вже Library.h і створюєтся Library.cpp


	
	enum Genre{ None , History, Comedy, Horror, Novel, Roman, Fantasy, 
	ScienceFiction, Detective} і тд - це тип даних що обєднує якісь значення і доступ до них по індексу
	
В классі прописуємо 
	Genre genre; 
задаємо значення по замовчанню
	genre = none;
	

В классі прописуємо 
	Genre genre; 

	class Book
	{
		int id;
		string title;
		int year;
		string author;
		int pages;
		Genre genre;
	
	
	
	
switch (вказується enum genre) і нажимаємо  мишкою і формується готовий свіч 
	
	void Book::ShowInfo() const
{
	cout << "Id : " << id << endl;
	cout << "Title : " << title << endl;
	cout << "Author : " << author << endl;
	cout << "Pages : " << pages << endl;
	cout << "Genre : ";
	switch (genre)
	{
	case None:cout << "None" << endl;break;
	case History:cout << "History" << endl;	break;
	case Comedy:cout << "Comedy" << endl;break;
	case Horror:cout << "Horror" << endl;break;
	і тд.
	
	
	
Конструктор переносу
		Library(Library && other)
		{
			this->name = other.name;
			this->books = other.books; перенос адресу масиву
			other.books = nullptr; - забирає у темпа вказку на адресу масиву
		}
		
Опаратор =

class Test  - що є в класі по замовчуванні
{
    //default constructor
    //destructor 
    //copy constructor
    //operator =
};

Конструктор копіювання спрацьовує для нового обєкта.
а в операторі = треба ще й почистити в тому обєкті в який копіюєм  масив

	Library& Library::operator=(const Library& other)
	{
		this->name = other.name;
		this->countBook = other.countBook;
		if (books != nullptr)
			delete[]books;
		this->books = new Book[countBook];
		for (int i = 0; i < countBook; i++)
		{
			this->books[i] = other.books[i];
		}
		return *this;
	}

========================================================================

Види пам"яті
Stack - статична память де зберігаються звичайні статичні змінні, і знищуються з будь яких фігурних дужках
Static - не ділянка яка зберігає статичні змінні які створюються на початку програми і знищуються коли програма закінччує свою роботу
HEAP - Heap Denamic memory


31_TemplateClass

Дають змогу реалізовувати один класс під різні типи данних (але НЕ для зміни кількості елементів)


template<typename T_X, typename T_Y>
class New_Point
{
	T_X x;
	T_Y y;
public:
}


	MyClass<long,string> cl1(long_arr, "Class with long collection");
	MyClass<char,string> cl2(char_arr, "Class with char collection"); - в <> вказуємо які саме типи данних ми використовуємо

Коли ми методи виносимо глобально то перед кожим методом

!!!!!! Якщо класс шаблонний, то його повністю треба зберігати в хедері, не виводячі методи в інший файл

31_1_InitializerList

Список ініціалізації


class Array
{
	int* arr;
	int size;
public:
	Array()
	{
		arr = nullptr;
		size = 0;
	}
	explicit Array(int size)
	{
		this->size = size;
		arr = new int[size] {};
	/*	for (int i = 0; i < size; i++)
		{
			arr[i] = 0;
		}*/
	}
	Array(const initializer_list<int> &list)  - конструктор що створює по списку ввідних даних, вказуємо який тип данних які приймаємо
	{
		this->size = list.size();
		arr = new int[size];
		/*for (int i = 0; i < size; i++)
		{
			arr[i] = list[i];
		}*/
		int i = 0;
		//foreach
		for (int elem : list)
		{
			arr[i++] = elem;
		}
	}
	void Fill(const initializer_list<int>& list)
	{
		if (arr != nullptr)delete[]arr;
		this->size = list.size();//3
		arr = new int[size];//032xfg132f  --- 0sdfsdfds
		int i = 0;
		//foreach		- foreach
		for (int elem : list)    - ліст це колекція яку ми підставлємо (в {}), елем - це тимчасова змінна через яку прописуємо кожну значення для копіювання в массив
		{
			arr[i++] = elem;
		}
	}
	~Array()
	{
		if (arr != nullptr)
			delete[]arr;
	}
	void Print()
	{
		for (int i = 0; i < size; i++)
		{
			cout << arr[i] << " ";
		}
		cout << endl;
	}
};
	
	
main()
{

	Array arr3({ 10,11,12,13,14,15,16,17,18,19,20,21,22,23 }); 
	
	
========================================================================
OOP Dynamic Data Structures. Stack. Queue

Динамічні структури даних

32_01_Stack

Stack - динамічниа структура даних, по суті масив.
Відрізняється тим що даємо запас ячеек, щоб не перестворювати кожен раз масив при додаванні нового елементу
 
!!!!!!!!! First in last out, last in first out - тобто перший зайшов в самий кінець, і виходить останнім після всіх хто зайшов після.


class Stack
{
	enum {EMPTY = -1, FULL = 9}  
	int arr[FULL+1]; 
	int topIndex;
public:     -в середині класу є такі методи:

	//default
    //delete
    //c-tor default
    //destructor
    //c-tor copy
    //move c-tor
    //operator =
	

	
	
	Stack (const Stack& other) = delete; - вказуємо що конструктор копіювання заборонено. 
	
	Це можна прописати тільки до стандартних методів, щоб вказати або дефолтну або заборонено

	
	Stack () - конструктор призначає топ індексу -1
	{
		topIndex = EMPTY;
	}
	bool Push(int elem)  - зміщає топ індекс на 1 і зберігає туди новий елемент
	 {
        if (!IsFull())
        {
            ++topIndex;
            arr[topIndex] = elem;
            //vs
            //arr[++topIndex] = elem;
            return true;
        }
        return false;
    }
	bool IsFull()const
    {
        return topIndex == FULL;
    }
    bool IsEmpty()const
    {
        return topIndex == EMPTY;
    }
	void Pop      - видаляє останній елемент
	{
        if (!IsEmpty())
            
            return arr[topIndex--];          
    }
	int GetCount()const
    {
        return topIndex + 1;
    }
    void Clear()
    {
        topIndex = EMPTY;
    }
    void Print()const
    {
        for (int i = 0; i < GetCount(); i++)
        {
            cout << arr[i] << " ";
        }
        cout << endl;
    }
	
	~Stack()=defaut; - вказуємо що цей дуструктор використовується по дефолту, іншого не створиш
	
}

========================================================================
32_02_DinamicStack

class Stack {
	enum{EMPTY = -1};
	int* arr;
	int size;
	int topIndex;
public:
	Stack () = delete; - забороняємо пустий конструктор, залишаючі тільки параметизований
	Stack(int size):size(size)//100
	{
		arr = new int[size];
		topIndex = EMPTY;
	}
	bool IsFull()const
	{
		return topIndex == size - 1;
	}
	bool Push(int elem)
	{
		if (!IsFull())
		{
			arr[++topIndex] = elem;
			return true;
		}
		return false;
	}
	bool IsEmpty()const
	{
		return topIndex == EMPTY;
	}
	int Pop()
	{
		if (!IsEmpty())
		{
			return arr[topIndex--];
		}
	}
	int Peek() - показує останній доданий елемент
	{
		if (!IsEmpty())
		{
			return arr[topIndex];
		}
	}
	int GetCount()const
	{
		return topIndex + 1;
	}
	void Clear()
	{
		topIndex = EMPTY;
	}
	void Print()const
	{
		for (int i = 0; i < GetCount(); i++)
		{
			cout << arr[i] << " ";
		}
		cout << endl;
	}
	~Stack()
	{
		if (arr != nullptr)
			delete[]arr;
	}
};
}

int main()
{
	Stack st(15);
	
	
32_03_Queue

Черга - перший прийшов, перший пішов. Останній пришов, останній пішов

class Quaue
{
	int* arr;
	int maxSize;
	int topIndex;
public:
	Queue()=default; - якщо вказаний будь який інший конструктор, то дефолтного не буде. А тут вказуємо щоб він залишався
	Queue(int max)
    {
        this->maxSize = max;
        arr = new int[maxSize];
        topIndex = 0;
    }
    bool IsEmpty()const
    {
        return topIndex == 0;
    }
    bool IsFull()const
    {
        return topIndex == maxSize;
    }
	
	
	void Enqueue (int elem) - додавання елементу в кінець
	{
        if (!IsFull())
        {
            arr[topIndex++] = elem;
        }
    }	
	int Dequeue () - удаляємо перший, і всі інші елементи посунуться на одну комірку вперед
	{
        if (!IsEmpty())
        {
            int first = arr[0];
            for (int i = 0; i < topIndex; i++)
            {
                arr[i] = arr[i + 1];
            }
            topIndex--;
            return first;
        }
    }
	int Dequeue()   - видаляємо перший, всі елементи на одну комірку вперед і перший стає в кінець
    {
        //кругова черга 
        if (!IsEmpty())
        {
            int first = arr[0];
            for (int i = 0; i < topIndex; i++)
            {
                arr[i] = arr[i + 1];
            }
            //topIndex--;
            arr[topIndex - 1] = first;
            return first;
        }
    }
	int GetCount()
    {
        return topIndex;
    }
    void Clear()
    {
        topIndex = 0;
    }

    void Show()
    {
        for (int i = 0; i < topIndex; i++)
        {
            cout << arr[i] << " ";
        }
        cout << endl;
    }

    ~Queue()
    {
        if (arr != nullptr)
            delete[]arr;
    }


}


#include <conio.h>

int num;
cin >> num; - бере до ентера

_getch(); - ловить один символ, зараз використовуємо як затримка монітора


========================================================================
33_QueueWithPriority

Види черг:
-Послідовна (звичайна),  перший пришов перший пішов
	-З пріоритетним включенням елементів
	- з приорітетним виключанням
-Кругова (перший стає в кінець)




Черга з пріорітетом

Черга з пріоритетним включенням елементів

Виходять всі по черзі, а вставляється по пріоритету, зсунувши елементи меньшого приоритету вправо

Елементи мають першочергово вже відсортовані

struct Element
{
	char value;
	int priority;
};
class QueueWithPriority
{
		Element* aar;
		int size;
public:
}

Черга з пріритетним виключенням елементів
елементи не сортовані, додаєм елемент в кінець, а вже видаляємо по пріоритету



========================================================================

34_SingleLinkedList

Single Linked List

Масив це ПОСЛІДОВНИЙ набір елементів

Ліст не массив, елементи розкидані по різним позиціям в HEAP
Перший знає про другого, другий знає третього, третій про четвертий і тд


Переваги:
	-для того щоб додати новий елемент, не треба чіпати інші елементи. Так же і при видаленні

Мінуси:
	сортування довго
	пошук довго
	

Один елемент називається 

	Node - нода

Кожна нода з двох елементів. Перше це значення яке хочемо зберігати, друге, це адреса наступного елемента черги



Порядок:
	Створюємо ноду, в ліву зберігаемо значення, праву частину вказуємо null
	При наступній ноді в попередній ноді зберігається адреса нової ноди

Для доступу в стеці робимо Head, в якій вказується адреса першої ноди
	

struct Node
{
	int value;
	Node *next;
	
	Node(int value, Node* next) :value(value), next(next) {} конструктор
};

class List
{
	Node* head;
public:
	List() - конструктор створює вказівник пустий
	{
		head = nullptr;
	} 
	void AddToHead(int value) - додаємо до голови
	{
		Node* newNode = new Node(value,head);      
        head = newNode;
	}
	void Print()const
    {
        Node* current = head;
        while (current != nullptr)
        {
            cout << current->value << " ";
            current = current->next;
        }
        cout << endl;
    }
	 ~List() - деструктор
	 Node* current = nullptr;
        while (head != nullptr)
        {
            current = head;
            head = head->next;
            delete current;
        }
    }
    void AddToTail(int value)
    {
        Node* newNode = new Node(value, nullptr);
        if (head == nullptr)
        {
            head = newNode;
        }
        else {
            Node* current = head;
            while (current->next != nullptr)
            {
                current = current->next;
            }
            current->next = newNode;
        }      
    }
    int GetElement(int pos)
    {
        Node* current = head;
        int i = 1;
        while (current != nullptr)
        {
            if (pos == i) return current->value;
            current = current->next;
            i++;
        }
    }
    int operator[](int pos)
    {
        Node* current = head;
        int i = 1;
        while (current != nullptr)
        {
            if (pos == i) return current->value;
            current = current->next;
            i++;
        }
    }
    void DeleteFromTail()
    {
        if (head == nullptr) return;
        if (head->next == nullptr)
        {
            delete head;
            head = nullptr;
          
        }
        else {
            Node* current = head;
            while (current->next->next != nullptr)
            {
                current = current->next;
            }
            delete current->next;
            current->next = nullptr;
        }

      
    }

========================================================================
35_DoubleLinkedList

Двозвязний ліст

Head знає де початок
Tail знає де кінец

Замість ноди на 2 елемента робим ноду з 3 елементами
Зліва вказіник на попередній, по середині значення, справа вказіник на наступний

у першого елемента на початку нулл (бо спереду більше немає елементів)  а хеад вкакується адреса першого елементиа

у останього елемента справа нуллптр (бо  далі комірок немає). А в тейлі вкащується адреса останнього елемента. 

========================================================================
36_BinaryTree

Бінарне дерево
також складається з Node

Йде ключ, потім значення, також *left та *right
root показуэ на перший елемент
Зберігає всі елементи відсортованими
Комірки можуть додаватися вліву сторону або в праву

Ноди поділяються на два види
Ноди що маються лефт або райт, називаєтсья гілка
ноди, що мають нуллптр з обох сторін, не мають жодної наступної ноди, називаютсья листочками

початкова нода має ключ, на приклад, 15, то меньше число йде на ліво, більше число на право, і по наступних гілках аналогічно

========================================================================

37_Inheritance

Наслідування

Робимо батьківський клас, який в собі має всі спільні дані і методи
І в наступних классах використовуємо цей клас

Наслідування - уникнення дублювання. 


class Enemy
{
protected:   - поля захищені від зовні, але класи наслідники можуть отримувати до них доступ
    string name;
    int health;
    float strength;
    static const int maxHealth = 100;
public:
    Enemy():name("no name"),health(0),strength (0){}
    Enemy(string name, int s):name( name),health(maxHealth),strength (s){}
    void Print()
    {
        cout << "Name : " << name << endl;
        cout << "Health : " << health << endl;
        cout << "Strength : " << strength << endl;
    }
	.....

class Dragon : public Enemy   - клас дракон наслідник класу енемі. В драконі є методи і змінні що в енеми
{
	float fire;
public:
	Dragon():fire(0), Enemy(){}    - дефолтним конструктором ініціалізуємо поле файр, а решта піде від батьківського конструктора
	Dragon(string n, int s, float f):fire(f), Enemy(n,s){} - вносимо необхідні дані, fire ініціалізуємо, а далі звертаємося до батьківського конструктора
	
	void Print
	!!!!!!!! 
	void Print()
    {
        cout << "------------- Dragon-------------------" << endl;
        Enemy::Print();		-  звертаємся до батьківського методу принт
        cout << "Fire : " << fire << endl;
    }

}

Якщо в батьківському класі змінні в прайват, то доступу до них немає, але з ідентифікатором доступу protected можна отримати до них доступ
private
public
protected - поля захищені від зовні, але класи наслідники можуть отримувати до них доступ



========================================================================


38_InheritancePolymorphism

class Car
{
private:
    string mark;
    float volume;
protected:
    int year;
    int mileage;
    int speed;
public:
	Car() :mark("no mark"), volume(0), year(0), mileage(0), speed(0) {}
	Car(string m, float v, int y, int ml) :
        mark(m), volume(v), year(y), mileage(ml), speed(0) {}
}

Наслідування може бути:
-public
	передається Public в Public
	передається Protected в Protected
	передається private - не доступні	
	
-protected
	передається Public в Protected
	передається Protected в Protected
	передається private   - не доступні	
-private
	передається Public в Private
	передається Protected в Private
	передається private в не доступні	



class PoliceCar : public Car 
{
	PoliceCar() :soundVolume(0), Car() {}
	PoliceCar(string m, float v, int y, int ml, float s) :soundVolume(s), 
        Car(m,v,y,ml) {} - спочатку викликається батьківський параметризований конструктор з такою кількістью параметрів як вказано тут в батьківському конструкторі, а гучність вже вказуємо тут
	
}

Поліморфізм
Дає можливість зробити методи в батьківському классі, перезавантажити їх у дочірньому классі, вони будуть мати можливість мати одне і те ж імя методу з реалізацією своєю. 

Це дає нам можливість працювати з массивом обєктів разних дочірних классів, які обєднані одним батьківським классом.
Буде один метод, на приклад void Say(), і в кожному дочірньому классі мати таку функцію, але зі своєю реалізацією

також дозволяє зробити глобальну універсальну функцію яка може приймати і батьківський класс і всіх наслідників.

Замість того щоб робити купу однакових функцій під всі дочірні класси, ми в вказуємо в авгументи тип файлу батьківського классу

void TestDrive(Car simpleCar)
{
    simpleCar.setSpeed(70);
    simpleCar.Drive();
}
Без поліморфізму використовуються тільки методи батьківського классу



virtual void Drive() - вказуємо virtual перед методом у батьківському класі, дає можливість наслідникам перевизначити ці функції. Працює тільки з почиланням на оригінал (Car& car) у глобальній функції 

void TestDrive(Car& simpleCar)
{
    simpleCar.setSpeed(70);
    simpleCar.Drive();
}

Перезавантаження - функція завжди нова, але з однаковою реалізацією, під різні види данних або кількості аргументів. В випадку шаблона компілятор все одино створює нову функцію 

Перевизначити - берем метод батьківського классу і змінюємо реалізацію

	virtual void TestDrive(Car& car) - слово віртуал вказується у батькувскому класі, дозволяє наслідникам перевизначити функцію (написати власну реалізацію)

void TestDrive() override 

	- override вказується у методах послідовних класів, щоб перевірити чи є такий метод в батьківському класс


Коли ми будем робити фіналку, салон, можемо зробити массив із різних дочірніх классів

main
{
	Car* carSalon[3]
    {
        new Car("Nissan",1.9,2015,30),
        new PoliceCar("Toyota",1.8,2020,70,90),
        new SportCar("Formula F1", 1.5, 2024, 100, 50) - робимо масив, ці разні елементи грузяться у HEAP, а масив в собі має вказівники на кожен елемент 
    };
	
	for (int i = 0; i < 3; i++)
    {
        
        carSalon[i]->Print(); - ми застосовуємо метод драйв для кожного елемента массиву
    }
    
    for (int i = 0; i < 3; i++)
    {
        delete carSalon[i]; - очистка всіх динамічяних обєктів в кінці роботи
    }


========================================================================
39_AbstactClass


Поліморфізм
Дає можливість зробити методи в батьківському классі, перезавантажити їх у дочірньому классі, вони будуть мати можливість мати одне і те ж імя методу з реалізацією своєю. 

Це дає нам можливість працювати з массивом обєктів разних дочірних классів, які обєднані одним батьківським классом.
Буде один метод, на приклад void Say(), і в кожному дочірньому классі мати таку функцію, але зі своєю реалізацією


В батьківському класі перед функцією ставиться vtrual для дозволу наслідникам перевизначити фукнцію 

	
Віртуальний метод

	virtual void Say() {} - батьківському класі перед функцією ставиться vtrual для дозволу наслідникам перевизначити фукнцію. 
	Має пусту реалізацію. Дозволяє викликати цю пусту функцію від обєкта батьківського классу
	
Чисто віртуальний метод:
	
	virtual void Say() const = 0 - чисто віртуальна функція, яка немає взагалі ніякої реалізації, забороняє викликати цю функцію від обєкта батьківського классу

Абстрактний класс	
	Цей класс з чисто віртуальною функцією virtual void Say() const = 0 перетворюється на АБСТРАКТНИЙ. А створювати екземпляри абстрактних класів заборонено.
	
В дочірньому классі:

	void Say() const override  - override вказується у методах послідовних класів, щоб перевірити чи є такий метод в батьківському класс
	
Якщо є абстрактний батьківський клас, то екземпляр батьківського класу не створиш. 

Можна зробити дочірній клас, де ОБОВЯЗКОВО маєм перезавантажити цю функцію, щоб була реалізація, тоді екземпляр джочірнього класу вже можна створити.

Якщо в дочірньому классі не перезавантажити функцію, то і дочірний класс перетворюється в абстрактний, і відповідно обєкт цього дочірнього класу вже не створиш


Через поліморфізм можемо створити масив батьківського класу, і покласти туди обєкти різних дочірніх классів


main{

	Animal * zoo[3]
	{
		&f,&l,&ant   - додаємо обєкти різних дочірніх класів в один массив, обовязково посиланням (&)
	}
	
	
========================================================================

40_VirtualDestructor

Віртуальний конструктор

Коли в дочірньому классі немає динамічних данних, то окремо писати деструктор в дочірньому не треба, спрацювує стандартний, тре свої данні і використовує батьківський деструктор

А коли в дочірньому массиві є динамічні данні, треба робити ще деструктор в дочірньому классі.

При наслідуванні спочатку чиститься дочірній класс, а потім с працьовує батьківський деструктор

Якщо є батьківський з динамічними даними, і в дочірній з динамічні дані, то треба робити деструктор і в дочірньому

virtual ~Person() - деструктор батьківського классу
	{
		if (marks != nullptr)
			delete[] marks;
} 

¬Aspirant()  - деструктор дочірнього классу
{
		if (subjects != nullptr)
			delete[]subjects;
	}

Ми вказуємо ланцюжок, спочатку дочірній деструктор, потім батьківський.

Але якщо в батьківському нема дінам даних і відповідно, немає деструктору
чисто віртуальний в батьківському virtual ~Person()=0;

========================================================================
41_MultyInheritance

Множинне наслідування


class Car
{

}

class Airplane
{

}


class FlyCat:public Car, public Airplane - робимо декілька батьківських класів
{

}
	
Якщо в батьківських классах повторюються назви функцій, то 

main

	((Car)fc).Use();
	((Airplane)fc).Use();
	
Проблеми множинного наслідування
	- одноіменні змінні і методи
	- алмаз смерті (приреченності) - це ситуація коли один класс має два батьківських, кожен з яких в свою чергу наслідуються від одного свого батьківського класу і в результаті що змінні приходять в наслідника від вершнього батьківського 2 рази
	
В результаті краще використовувати одинарне наслідування
	
	int getValue()
	{
		return B::value;
		return C::value;
		return B::A::value;
		return C::A::value;

========================================================================
42_AgregationComposition

Агрегація і композиція

перед програмуванням складається діаграма

	- use case diagram - діагарама що відображають екторів (дійові особи) і use case (що вони можуть робити) - сама актуальна
		
	- class diagram - діаграми классів, описані класи і методи і звязок між классами
	
		
		Типи звязку:

Композиція в програмуванні- це коли один клас складається з інших класів, і вони є невідємною його частиною. (Наприклад, є принтер. Окремо є класс сканер і класс картридж. В классі принтер є сканер, і массив картриджей)

Асоціація - це коли класи взаємодіють між собою, і ми можемо реальзувати звязок один до одного, один до багатьох і багато до багатьох

Агрегація - це взяємодія між классами коли звязок не обовязковий, може бути, може не бути (принтер без файлу для друку норм себе почуває, друк може бути а може і не бути)


========================================================================
43_Exceptions

throw - кинути помилку

try  - зона в якій розміщаємо код який може викликати помилку

catch - зловити 

float Divide(float a, float b)
{
	float res = 0;
	if (b == 0)
	{
		throw exception("Divide by zero"); - якщо нема catch для цього типу данних то зупиняє функцію, і викідає помилку і прога крашиться
	}
	

main(){

	try
		{
			Login(login, password);
		}	
		catch (PasswordInvalidException ex) - - ловим помилку і програма продовжує роботу. Орієнтується яка помилка по типу даних
		{
			cout << "Password must start with lowwer letter " << endl;
			cout << ex.what() << endl;
		}
	
	catch (int ex) - ловить помилку типу данних int
	
	catch (const char* ex) - ловить стрінгу

	catch(...) - універсальний кетч, ловить будь який тип данних (будь яку помилку)
	

	int& operator[](int index)
	{
		if (index >= size || index < 0)
			throw out_of_range("Index is less that 0 or more than size"); - - це стандартний тип помилки з бібліотеки
		else
			return arr[index];
			
Помилки йдуть у вигляді классів
exception --> logic_error --> invalid_argument
Можна ловити спочатку дочірню помилку, якщо для неї кетча немає то спрацює кетч батьківського класск

кетчі розташовувати починаючи з самих дочірніх, а потім середні а в кінці уже catch(...)

========================================================================
44_01_SaveReadFile


#include <fstream>

ofstream
ifstream
fstream



Запис у файл   text

#include <fstream> - file stream

int main()
{
	string fname = "my.txt"; (файл створиться або перезапишеться, якщо вже є)
	ofstream f(fname); // створили обєкт файлового потоку f і повязали цей потік з фізичним файлом
	if (!fout.is_open())
    {
        cout << "Error opening file\n";
        return 0;
    }
	f << "Hello"; - записує в файл
	f.close(); - закриває файл
	
	ifstream fin(fname);
    char readText[256];
    int readValue;

    //fin >> readText; // прочитає перше слово
    fin.getline(readText, 100);
    fin >> readValue;

    cout << "Read text from file : " << readText << endl;
    cout << "Read value from file : " << readValue << endl;
	
}

Запис у файл  text
	#include <fstream>

	ofstream fileOut; - підключаємо потік до файлу
	fileOut.open("file") - вказуємо шлях до файлу
	або
	ofstream fileOut("file));

	if (!fout.is_open())


	fileOut << !!!!!!!


	!!!
	cout !!!!!


	fileOut.close; - закриття файлу


Зчитати з файла text

	ifstream fileIn;
	fileIn.open("file.txt")
	
	!!!!
	
	

	string str1;
	
	while!!!!!

		getline!!!!!!!

	fileIn.close();
	
	
	
Бінарний запис  (для ООР)

	ofstream fileOut("binary!!!!!!!
	
	
	fileOut.write!!!!   - 
	
	
========================================================================
44_02_ZooSaveToFile

ofstream& operator <<(ofstream& out, const Animal& animal)	 	- функція перезавантаження оператора <<
{
	out << animal.name << " " << animal.type << " " << animal.age << " " << animal.weight;
	return out;
}
ifstream& operator >>(ifstream& in,  Animal& animal) 
{
	in >> animal.name >> animal.type >> animal.age >> animal.weight;
	return in;
}
	

class Zoo{
	string name;
	Animal* animals;
	int countAnimal
public
	Zoo():name("no name"), animals(nullptr),countAnimal(0){}
	Zoo(string name):name(name), animals(nullptr),countAnimal(0){}
	
	void AddAnimal(Animal an)//3 + 1
	{
		countAnimal++;//4
		Animal* temp = new Animal[countAnimal];
		for (int i = 0; i < countAnimal-1; i++) - створюємо массив обєктів енімал
		{
			temp[i] = animals[i];
		}
		temp[countAnimal - 1] = an;
		delete[]animals;
		animals = temp;
	}
	
	void BinaryWrite()
	{
		ofstream out("Zoo.bin", ios_base::out | ios_base::binary); -  	out запис, binary - бінарним методом
		out.write((char *)&name, sizeof(name)); - переиворюємо на чаровий массив, передаємо оригінал по посиланню, далі в size of вказуємо тип данних щоб воно зрозуміло розмір потоку ці данні (тут стрінга, поле нейм)
		out.write((char *)&countAnimal, sizeof(countAnimal));
		for (int i = 0; i < countAnimal; i++)
		{
		out.write((char *)&animals[i], sizeof(animals[i]));

		}
		out.close();
		cout << "Save to file  binary" << endl;
	}
	
	void BinaryRead()
	{
		ifstream in("Zoo.bin", ios_base::in | ios_base::binary);
		in.read((char*)&name, sizeof(name));
		in.read((char*)&countAnimal, sizeof(countAnimal));
		animals = new Animal[countAnimal];
		for (int i = 0; i < countAnimal; i++)
		{
			in.read((char*)&animals[i], sizeof(animals[i]));
			
		}
		in.close();

	}
========================================================================
45_STL_Vector

	Standart Template Library - набір шаблоних методів для роботи з різними типами данних
	
	В цих шаблонних класах обовязково є вказівники.
	є показчик v.begin() - arr[0], v.end() - показує першу ПУСТУ комірку
	
	
	
vector<int> - це шаблонний контейнер, який створює динамічний массив (постійно перевиділяти), але сам виділяє і чистить динамічну память. Так як це шаблон, треба вказати тип данних.
	
	for (int el : v2)  - foreach - тільки для читання, для зміни звичвйний фор
	{
		cout !!!
	}
	v.size() - кількість елементів
	v.capacity() - кількість зарезервованих комірок
	
	
	Виділяння елементів
	v2.erase(v2.begin()) - видаленя першого елементу
	v2.erase(v2.begin() + 2 , v2.end()-2)  - видалення діапазону
	
	додавання елемента
	
	v.begin() - arr[0], v.end() - показує першу ПУСТУ комірку, бо зарезервованих завжди більше чим занятих
	
	v.size() - кількість елементів
	v.capacity() - кількість зарезервованих комірок
	
	v2.insert(v2.begin(), {11,12,12}); - додали инитиалайзинг лист
	v2.insert(v2.end(), 4, 5)	-куди, скільки разів, і значення
	v2.insert(v2.begin(), 77) - в першу комірку ставимо 77
	v2.insert(v2.end(), v3.begin)
	
	v2.push_back(444); - додаємо в кінець
	v2.pop_back(); - виділяємо з кінця
	
	v2.swap(v3); - поміняли  місцями v2 та v3
	v2.front() - показує перший елемент
	
	v2.resize(20) - коли збільшуєш, в пусті комірки додаються нулі
	
	v2.shrink_to_fit(); - очищення невикористаної памяті (комірок)
	
		
========================================================================
46_StackQueque

	stack - це також шаблонний клас з динамічним масивом але з правилами стека.  Перший прийшов, останній вийшов
	
	Черга
	queue<string> clients 
	перший пришов, перший пішов
	
	пріоритетна черга
	!!!!!!!!!
	треба перезагружати оператор > 
	
	Двохстороння черга
	deck.<int> deck;
	
========================================================================
Збереження 
Читання з файлу
ексепшени

інкапсуляція, наслідування, поліморфізм
композиція і агрегація

перші 4 - обязково писати код

16 не буде
23--
25---






	
	
	