01_Вступ до мови програмування C++

с++ - компільована мова програмування
Строго типізована мова

viasual studio

workloads - deckstop development with c++

ctrl + F5 - запуск програми
просто F5 - дебагер
ctrl + D - клон рядка

ctrl + alt + l  відкривається права панель з файлами

ctrl + K + F  виправляється формат коду

F10 debager

-------------------------
#include<iostream>
using namespace std;

void main()
------------------------------


void main() - основна функція, точка входу в програму
void - озаначає що функція нічого не повертає

cout << "Hello world";  - типа принт 
cout << "You have to pay : " << price << " grn"; - вивід змінної price

Типи даних: - визначає першим ділом розмір комірочки і тип інформації що записуються
	1.Числові
		дроби
			float  - 4 bites
			double - 8 bites (16 цифр після коми
		цілі
			int - 4b 
			short 2b from -32768 to 32767
			long 4b 
			long long 8b - нереально велике число
			
			unsigned int - тільки в додатньому діапізоні
	2.Текст
			char - один символ 1байт (в одинарних ' ')
	3.Логіка
		bool - 1байт true false
	
	enum - набір цілочісельних констант

перетворення типів даних:
	Звужуюча форма (втрачаються частина даних)
		int a = 23.5; - знаки після коми відкидаються 
	розширююче перетворення:
		double x = 3.21; (насправді х = 3,2100000000000000)
		
	явне перетворення:
		double k = 37.4; (37.400000000000000)
		float r = (int) k; (float 37.00000000)
	неявне:
		
	Уніфікована ініціалізація
		int num1 = 11.3; (num = 11.00000)
		int num2 = {11.3} - при компіляції буде помилка
		


		
правила назв зміних те саме що на пайтоні
при створенні зміної спочатку вказується тип
int age = 16;

Константа:
conts float PI = 3.14; - це значення вже змінити не можна

ввід з клавіатури:
int numer;
cout << "enter number: "
cis >> number;


========================================================================
02 logic operators

оператор - конструкція мови що призводить дії над даними

унарні -5 -1 -9 +6
Бінарні * - + / %

// - виводить ціле число а залишок пілся коми відкидає
% - виводить залишок після цілого ділленя. Якщо ==0, значить число ділиться без залишку. Коли меньше число ділимо на більше, тоді результат меньше число (10%12=10)

+= 
-=
%=
/=
*=

оператори порівння
	< > 

оператори рівності
	== дорівнює
	!= — не равно

Логічні оператори 
	1 (true)
	0 (false)
	&& - and
	|| - or
	!  - not
	if
	else if      (elif)
	else

Тернарний оператор	
	інкримент ++
		постфіксна форма: a++; (те саме що а += 1;)
		префіксна форма: ++а;  (те саме що а += 1;)

	декремент --
		постфіксна форма: a--; (те саме що а -= 1;)
		префіксна форма: --а;  (те саме що а -= 1;)

перетворення типів даних:
	Звужуюча форма (втрачаються частина даних)
		int a = 23.5; - знаки після коми відкидаються 
	розширююче перетворення
		int a = 3000000000; (не влазить значення

	
if (b==0)
{

}
else
{

}

Тернарний оператор
   ТВЕРДЖЕННЯ АБО ВИРАЗ ? ДІЯ1 : ДІЯ2;
		(b == 0) ? cout << "You can*t divide by zero!!!!" << endl : cout << "Result = " << a / b << endl;
		(b != 0) ? cout << "Result = " << a / b << endl : cout << "You can*t divide by zero!!!!" << endl;
		
		max = (a > b) ? a : b;
		min = (a < b) ? a : b;

========================================================================
03_Switch Enum

switch (grade)
	{
	case 'A':case 'a':
		cout << "Your grade is 5" << endl;
		break;
	case 'B':
		cout << "Your grade is 4" << endl;
		break;
	case 'C':
	case 'c':
		cout << "Your grade is 3" << endl;
		break;
	case 'D':
	case 'd':
		cout << "Your grade is 2" << endl;
		break;
	case 'F':
	case 'f':
		cout << "Your grade is 1" << endl;
		break;
	default:
		cout << "This grade is invalid\n";
		break;
	}
	
Якщо немає braak в case то виконується все кайси до того як наштовхнейться на брейк
char key то треба вказувати в один лапках 
	case '+':
int key то  
	case 1:

	case 'A':case 'a': - можна перераховувати кейси один за одиним і ставити їм уодну дію
	
enum - набір цілочісельних констант.

enum coins{penny = 1 , nickel = 5, dime =10 , quarter = 25 , half= 50 , dollar_coin = 100};

по замовчуванню, якщо не задати данні то задається 0,1,2 ітд
enum coins{penny, nickel, dime = 10, quarter, half= -1 , dollar_coin }; - йде спочатку 0,1,10,11, -1, 0
Тобто перерахування від вянказаного значення поки не вказати нове значення

========================================================================
Цикли
04_while 

Цикл з передумовою(while);

	int counter = 1;
	while (counter <= 7)
		{
		cout << "You have seen the " << counter <<
			" Wonder of the world!!!\n";
		counter++;
		}
	cout << "Now, you can begin your essay.\n";
	
Цикл з постумовою(do...while); //while True ..if break

	do
	{
		cout << "Choose operation : " << endl;
		cout << "[ 1 ] - If you want to Add two number " << endl;
		cout << "[ 2 ] - If you want to Deduct two number " << endl;
		...
		cin >> key;
		switch (key)
		{
		case 1:
			cout << "Enter a : "; cin >> a;
			cout << "Enter b : "; cin >> b;
			res = a + b;
			cout << "Answer : " << a << " + " << b << " = " << res << endl;
			break;
			
			.....
			
			cout << "Enter a : "; cin >> a;
			cout << "Enter b : "; cin >> b;
			if (b != 0)
			{
				res = a / b;
				cout << "Answer : " << a << " / " << b << " = " << res << endl;
			}
			else
			{
				cout << "\nError! You cannot divide by "
					"zero!\n";
			}
			break;
		case 0:
			cout << "Have a nice!!!" << endl;
			break;
		default:
			cout << "Wrong choice......" << endl;
			break;
		}
	} while (key!=0);


========================================================================
05_for_06_includeCycles

Цикл for, Вкладені цикли, Debuger

Цикл з параметрами(for).
 
	for (size_t i = 0; i < length; i++)
	
	for (int i = 0; i < 10; i++) - i створюються всередині циклу і знищується
	{
		cout << i << " ";
	}
break, continue працюють
	
Безкінечний цикл
int number;
	int sum = 0;
	for ( ;  ;  )// реалізація нескінченного циклу
	{
		cout << "Enter number : "; 
		cin >> number;
		if (number == 0)break;
		sum += number;
	}
	cout << "Suma all numbers = " << sum << endl;
	
Вкладені цикли

	int size = 10;

    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            if (i >= j && i + j >= size - 1)
                cout << "|===|";
            else
                cout << "     ";
        }
        cout << endl;
    }
	
========================================================================
Масиви, дебагер
07_Array

Типи помилок:
	- Помилка на етапі компілації (синтатична помилка)
	- Помилка на етапі виконання (прога запустилась але крашнулась)

Дебагер
F10 - старт дебагера спочатку коду, F10 переходимо на наступний рядок покроково
стаємо на потрібний рядок і F9, або зліва ставимо червону точку
F5 прога пробігає код до точкі зупинки, F10 далі
В циклі щоб не перебігати всі етирації циклу, правою кнопкою на точку зупинки і обираємо з умовами

Масиви (array) - набір однотипних даних об"єднаний загальним імя"м
	int arr[3]; - всі комірки будуть типу даних int
	arr[0] = 3;
	
	const int size = 5;
	int new_arr[size];
	int arr[size] = {1,30,5,4,7};
	int arr4[size] = {} - для того щоб все заповнилось нулями
Заповнення масиву за допомогою циклу
	cont int size = 5;
	int arr[size];
for (int i = 0; i < SIZE; i++)
    {
        cout << "Enter " << i + 1 << " element ";
        cin >> arr5[i];
    }
Вивід масиву
	for (int i = 0; i <SIZE; i++)
    {
        cout << arr5[i] << " ";
    }
    cout << endl;

========================================================================
08_Random_Matrix

Види пам"яті
Stack - елементи складаються одна на одну
Static - 
Heap Denamic memory

srand(time(0)); - вказує точку відправки відносно часу, вказується ОДИН раз на початку коду
а = rand(); - згенерує ціле число від 0 до 32767

ЧИСЛО В ДІАПАЗОНІ ВІД НУЛЯ ДО Х: rand() % X

ЧИСЛО В ДІАПАЗОНІ ВІД Х  ДО Y : rand() % (Y - X) + X
        //(16-11)
        a = rand() % (16-11) + 11;

Багатовимірні масиви 
Матриця - це сукупність одновимірних масивів

	srand(time(0));
	
	const int row = 5;
	const int col = 6;
	int array[row][col];
    
    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < col; j++)
        {
            array[i][j] = rand() % 90 + 10;//10...100
            cout << array[i][j] << " ";
        }
        cout << endl;
    }
    cout << endl;

